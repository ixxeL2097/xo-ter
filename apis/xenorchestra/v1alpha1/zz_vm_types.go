/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CdromObservation struct {
}

type CdromParameters struct {

	// +kubebuilder:validation:Required
	ID *string `json:"id" tf:"id,omitempty"`
}

type DiskObservation struct {
	Position *string `json:"position,omitempty" tf:"position,omitempty"`

	VbdID *string `json:"vbdId,omitempty" tf:"vbd_id,omitempty"`

	VdiID *string `json:"vdiId,omitempty" tf:"vdi_id,omitempty"`
}

type DiskParameters struct {

	// +kubebuilder:validation:Optional
	Attached *bool `json:"attached,omitempty" tf:"attached,omitempty"`

	// +kubebuilder:validation:Optional
	NameDescription *string `json:"nameDescription,omitempty" tf:"name_description,omitempty"`

	// +kubebuilder:validation:Required
	NameLabel *string `json:"nameLabel" tf:"name_label,omitempty"`

	// +kubebuilder:validation:Required
	Size *float64 `json:"size" tf:"size,omitempty"`

	// +kubebuilder:validation:Required
	SrID *string `json:"srId" tf:"sr_id,omitempty"`
}

type NetworkObservation struct {
	Device *string `json:"device,omitempty" tf:"device,omitempty"`

	IPv4Addresses []*string `json:"ipv4Addresses,omitempty" tf:"ipv4_addresses,omitempty"`

	IPv6Addresses []*string `json:"ipv6Addresses,omitempty" tf:"ipv6_addresses,omitempty"`
}

type NetworkParameters struct {

	// +kubebuilder:validation:Optional
	Attached *bool `json:"attached,omitempty" tf:"attached,omitempty"`

	// +kubebuilder:validation:Optional
	MacAddress *string `json:"macAddress,omitempty" tf:"mac_address,omitempty"`

	// +kubebuilder:validation:Required
	NetworkID *string `json:"networkId" tf:"network_id,omitempty"`
}

type VMObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	IPv4Addresses []*string `json:"ipv4Addresses,omitempty" tf:"ipv4_addresses,omitempty"`

	IPv6Addresses []*string `json:"ipv6Addresses,omitempty" tf:"ipv6_addresses,omitempty"`

	PowerState *string `json:"powerState,omitempty" tf:"power_state,omitempty"`
}

type VMParameters struct {

	// +kubebuilder:validation:Optional
	AffinityHost *string `json:"affinityHost,omitempty" tf:"affinity_host,omitempty"`

	// +kubebuilder:validation:Optional
	AutoPoweron *bool `json:"autoPoweron,omitempty" tf:"auto_poweron,omitempty"`

	// +kubebuilder:validation:Optional
	BlockedOperations []*string `json:"blockedOperations,omitempty" tf:"blocked_operations,omitempty"`

	// +kubebuilder:validation:Optional
	CPUCap *float64 `json:"cpuCap,omitempty" tf:"cpu_cap,omitempty"`

	// +kubebuilder:validation:Optional
	CPUWeight *float64 `json:"cpuWeight,omitempty" tf:"cpu_weight,omitempty"`

	// +kubebuilder:validation:Optional
	Cdrom []CdromParameters `json:"cdrom,omitempty" tf:"cdrom,omitempty"`

	// +kubebuilder:validation:Optional
	CloudConfig *string `json:"cloudConfig,omitempty" tf:"cloud_config,omitempty"`

	// +kubebuilder:validation:Optional
	CloudNetworkConfig *string `json:"cloudNetworkConfig,omitempty" tf:"cloud_network_config,omitempty"`

	// +kubebuilder:validation:Optional
	CoreOs *bool `json:"coreOs,omitempty" tf:"core_os,omitempty"`

	// +kubebuilder:validation:Required
	Cpus *float64 `json:"cpus" tf:"cpus,omitempty"`

	// +kubebuilder:validation:Required
	Disk []DiskParameters `json:"disk" tf:"disk,omitempty"`

	// +kubebuilder:validation:Optional
	ExpNestedHvm *bool `json:"expNestedHvm,omitempty" tf:"exp_nested_hvm,omitempty"`

	// +kubebuilder:validation:Optional
	HighAvailability *string `json:"highAvailability,omitempty" tf:"high_availability,omitempty"`

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	HvmBootFirmware *string `json:"hvmBootFirmware,omitempty" tf:"hvm_boot_firmware,omitempty"`

	// +kubebuilder:validation:Optional
	InstallationMethod *string `json:"installationMethod,omitempty" tf:"installation_method,omitempty"`

	// +kubebuilder:validation:Required
	MemoryMax *float64 `json:"memoryMax" tf:"memory_max,omitempty"`

	// +kubebuilder:validation:Optional
	NameDescription *string `json:"nameDescription,omitempty" tf:"name_description,omitempty"`

	// +kubebuilder:validation:Required
	NameLabel *string `json:"nameLabel" tf:"name_label,omitempty"`

	// +kubebuilder:validation:Required
	Network []NetworkParameters `json:"network" tf:"network,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceSet *string `json:"resourceSet,omitempty" tf:"resource_set,omitempty"`

	// +kubebuilder:validation:Optional
	StartDelay *float64 `json:"startDelay,omitempty" tf:"start_delay,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Required
	Template *string `json:"template" tf:"template,omitempty"`

	// +kubebuilder:validation:Optional
	Vga *string `json:"vga,omitempty" tf:"vga,omitempty"`

	// +kubebuilder:validation:Optional
	Videoram *float64 `json:"videoram,omitempty" tf:"videoram,omitempty"`

	// +kubebuilder:validation:Optional
	WaitForIP *bool `json:"waitForIp,omitempty" tf:"wait_for_ip,omitempty"`
}

// VMSpec defines the desired state of VM
type VMSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VMParameters `json:"forProvider"`
}

// VMStatus defines the observed state of VM.
type VMStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VMObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VM is the Schema for the VMs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,xojet}
type VM struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VMSpec   `json:"spec"`
	Status            VMStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VMList contains a list of VMs
type VMList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VM `json:"items"`
}

// Repository type metadata.
var (
	VM_Kind             = "VM"
	VM_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VM_Kind}.String()
	VM_KindAPIVersion   = VM_Kind + "." + CRDGroupVersion.String()
	VM_GroupVersionKind = CRDGroupVersion.WithKind(VM_Kind)
)

func init() {
	SchemeBuilder.Register(&VM{}, &VMList{})
}
